# РГР2: Моделирование случайного блуждания на суперкомпьютере

## Описание проекта

Данный проект реализует модель одномерного случайного блуждания для выполнения на суперкомпьютере и локальной машине с последующим сравнением результатов.

## Структура проекта

```
.
├── random_walk.py      # Основной скрипт моделирования
├── visualize.py        # Скрипт для визуализации результатов
├── requirements.txt    # Зависимости Python
├── run_local.sh        # Скрипт для локального запуска (опционально)
├── run_supercomputer.sh # Скрипт для запуска на суперкомпьютере
└── README.md           # Данный файл
```

## Установка зависимостей

### Локально

```bash
pip install -r requirements.txt
```

### На суперкомпьютере

Обычно на суперкомпьютерах Python окружения управляются через модули. Пример:

```bash
module load python3
pip install --user numpy matplotlib
```

Или если используется conda:
```bash
conda create -n random_walk python=3.9
conda activate random_walk
conda install numpy matplotlib
```

## Использование

### 1. Локальное выполнение

#### Запуск с параметрами по умолчанию (N=10^4, M=10^8):
```bash
python random_walk.py
```

#### Запуск с пользовательскими параметрами:
```bash
python random_walk.py [N] [M] [platform] [seed] [batch_size]
```

**Важно для сравнения**: Используйте одинаковые параметры (N, M) и одинаковый seed на обеих платформах!

Примеры:
```bash
# Для сравнения результатов - используйте одинаковые параметры и seed:
python random_walk.py 10000 100000000 local 42      # Локально
python random_walk.py 10000 100000000 supercomputer 42  # На суперкомпьютере

# Тестирование с меньшими параметрами:
python random_walk.py 1000 1000000 local 42

# Скрипт для автоматического запуска с одинаковыми параметрами:
python run_same_params.py  # Запустит локально с параметрами для сравнения
```

**Параметры:**
- `N` - число шагов (по умолчанию: 10000)
- `M` - число траекторий (по умолчанию: 100000000)
- `platform` - платформа: 'local' или 'supercomputer' (по умолчанию: 'local')
- `seed` - seed для генератора случайных чисел (по умолчанию: None, случайный)
- `batch_size` - размер пакета для обработки (по умолчанию: автоматический)

#### Генерация визуализаций:
```bash
python visualize.py
```

### 2. Выполнение на суперкомпьютере

#### Шаг 1: Загрузка кода на суперкомпьютер через GitHub

1. Создайте репозиторий на GitHub
2. Закоммитьте код:
```bash
git init
git add .
git commit -m "Initial commit"
git remote add origin https://github.com/ваш_username/ваш_репозиторий.git
git push -u origin main
```

3. На суперкомпьютере клонируйте репозиторий:
```bash
git clone https://github.com/ваш_username/ваш_репозиторий.git
cd ваш_репозиторий
```

#### Шаг 2: Установка зависимостей на суперкомпьютере

```bash
module load python3  # или другой способ загрузки Python
pip install --user numpy matplotlib
```

#### Шаг 3: Запуск моделирования

**ВАЖНО**: Для корректного сравнения используйте одинаковые параметры и seed на обеих платформах!

**Вариант A: Прямой запуск (если достаточно ресурсов)**
```bash
# Используйте тот же seed, что и на локальной машине (например, 42)
python random_walk.py 10000 100000000 supercomputer 42
```

**Вариант B: Через систему очередей (SLURM/PBS)**
Создайте файл `submit_job.sh`:

```bash
#!/bin/bash
#SBATCH --job-name=random_walk
#SBATCH --nodes=1
#SBATCH --ntasks=1
#SBATCH --cpus-per-task=1
#SBATCH --mem=16G
#SBATCH --time=01:00:00
#SBATCH --output=random_walk_%j.out
#SBATCH --error=random_walk_%j.err

module load python3
python random_walk.py 10000 100000000 supercomputer 42
```

Затем отправьте задачу:
```bash
sbatch submit_job.sh  # для SLURM
# или
qsub submit_job.sh    # для PBS
```

#### Шаг 4: Скачивание результатов

После завершения выполнения на суперкомпьютере:

1. Закоммитьте результаты в репозиторий (или используйте scp):
```bash
git add results/
git commit -m "Results from supercomputer"
git push
```

2. Или скачайте напрямую через scp:
```bash
scp username@supercomputer:/path/to/results/* ./results/
```

3. На локальной машине запустите визуализацию:
```bash
python visualize.py
```

### 3. Сравнение результатов

Скрипт `visualize.py` автоматически создаст графики сравнения, если обнаружит результаты как с локальной машины, так и с суперкомпьютера. 

Для явного указания платформы можно:
- Переименовать файлы результатов, добавив суффикс `_local` или `_supercomputer`
- Или модифицировать скрипт для чтения из разных директорий

## Параметры моделирования

- **N** (число шагов): 10^4 (по умолчанию)
- **M** (число траекторий): 10^8 (по умолчанию)

**Внимание**: 
- M=10^8 требует значительных ресурсов памяти (~8-10 ГБ RAM). Для тестирования используйте меньшие значения.
- **Для корректного сравнения** используйте одинаковые N, M и seed на обеих платформах. Скрипт автоматически использует пакетную обработку на локальной машине для экономии памяти.

## Результаты

Скрипт создает следующие файлы в директории `results/`:

1. `results_N{N}_M{M}.json` - JSON файл с численными результатами
2. `positions_sample_N{N}_M{M}.npy` - Выборка финальных позиций для визуализации
3. `statistics_comparison.png` - Графики статистических характеристик
4. `position_distribution.png` - Графики распределения позиций
5. `comparison_report.png` - Отчет сравнения локального и суперкомпьютерного выполнения

## Формат выходных данных

JSON файл содержит:
```json
{
    "N": 10000,
    "M": 100000000,
    "platform": "local",
    "seed": 42,
    "batch_size": 1000000,
    "mean_position": 0.123456,
    "mean_squared_displacement": 10001.23,
    "std_position": 100.5,
    "min_position": -500,
    "max_position": 450,
    "elapsed_time_seconds": 123.45,
    "theoretical_mean_position": 0.0,
    "theoretical_mean_squared_displacement": 10000.0,
    "error_mean_position": 0.123456,
    "relative_error_msd": 0.0123
}
```

## Теоретические ожидания

- **Средняя позиция**: ≈ 0 (шаги +1 и -1 равновероятны)
- **Среднее квадратичное смещение**: ≈ N (для N=10^4 ожидается ≈ 10^4)

## Устранение неполадок

### Недостаточно памяти

Если возникает ошибка нехватки памяти:
1. Уменьшите M (число траекторий)
2. Используйте меньшие значения для тестирования
3. На суперкомпьютере запросите больше памяти в задаче

### Медленное выполнение

- Убедитесь, что используется NumPy с оптимизацией (BLAS/LAPACK)
- На суперкомпьютере запросите больше CPU ядер (хотя текущая версия однопоточная)

### Проблемы с визуализацией

- Убедитесь, что matplotlib установлен и может создавать графики
- На суперкомпьютере без дисплея используйте `matplotlib.use('Agg')` в начале скрипта

## Автор

Создано для РГР2 по дисциплине, связанной с суперкомпьютерами.

## Лицензия

Учебный проект.

